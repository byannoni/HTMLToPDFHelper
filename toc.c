
#include "stdafx.h"
#include "toc.h"
#include "util.h"
#include "wkhtmltopdf_cmd.h"
#include "log.h"

static void skip_bin_data(FILE*);

/*
 * NOTE: This method is unreliable. See this StackOverflow question:
 * http://stackoverflow.com/questions/14644353/
 *
 * This procedure reads the PDF with the given name and hopefully
 * returns the number of pages it has. It searches for "/Count " in the
 * file and assumes the following number is the number of pages. This
 * will not work for every PDF (as noted above), but it seems to work
 * with the PDFs generated PDFs from wkhtmltopdf. If the procedure
 * succeeds (i.e. finds a number which may be the number of pages as
 * determined by the method explained above), and the number of pages in
 * stored in the value pointed to by pages. Otherwise, execution is
 * terminated. The value of neither pages nor pdf_name may be NULL.
 */
void get_number_of_pages(unsigned long int* pages, LPCTSTR pdf_name)
{
	FILE* pdf = NULL;
	static TCHAR pages_line[] = _T("/Count ");
	static TCHAR stream_start[] = _T("stream\n");
	static const size_t pages_line_len = LENGTHOF(pages_line) - 1;
	static const size_t stream_start_len = LENGTHOF(stream_start) - 1;
	TCHAR line[BUFSIZ] = _T("");

	RT_NOT_NULL(pdf_name);
	RT_NOT_NULL(pages);

	pdf = require_open_file(pdf_name, _T("r"));

	while(_fgetts(line, LENGTHOF(line), pdf) != NULL) {
		if(_tcsncmp(stream_start, line, stream_start_len) == 0) {
			skip_bin_data(pdf);
			continue;
		}

		if(_tcsncmp(pages_line, line, pages_line_len) == 0) {
			LPCTSTR pages_number = _tcstok(line + pages_line_len, _T(" "));

			if(pages_number != NULL) {
				LPTSTR end = NULL;

				errno = 0;
				*pages = _tcstoul(pages_number, &end, 10);

				if(*pages != ULONG_MAX || errno != ERANGE) {
					release_file(pdf);
					return;
				}
			}
		}

		if(_tcschr(line, _T('\n')) == NULL)
			skip_line(pdf);
	}

	errorout(E_PDF, _T("Failed to get number of pages from segment"));
}

/*
 * Parse the outline XML generated by wkhtmltopdf set the title and page
 * target of each item found. The buffer pointed to by title is filled
 * with the title and the value pointed to by rel_page is set to the
 * page number. This procedure sets the values pointed to by title and
 * rel_page if an item was found. Otherwise, the value pointed to by
 * title is unspecified and the value pointed to by rel_page is
 * ULONG_MAX. The values of title, rel_page and outline must not be
 * NULL. The buffer pointed to by title must be at least title_len in
 * length.
 */
void get_toc_item(LPTSTR title, size_t title_len, unsigned long int* rel_page,
		FILE* outline)
{
	static TCHAR title_str[] = _T("<item title=\"");
	static TCHAR page_str[] = _T("\" page=\"");
	static const size_t title_str_len = LENGTHOF(title_str) - 1;
	static const size_t page_len = LENGTHOF(page_str) - 1;
	TCHAR line[BUFSIZ] = _T("");

	RT_NOT_NULL(outline);
	RT_NOT_NULL(title);
	RT_NOT_NULL(rel_page);

	*rel_page = ULONG_MAX;

	while(_fgetts(line, LENGTHOF(line) - 1, outline) != NULL) {
		LPTSTR item = _tcsstr(line, title_str);
		LPTSTR page = _tcsstr(line, page_str);

		if(item != NULL && page != NULL) {
			LPTSTR end = NULL;

			page[0] = _T('\0');
			item += title_str_len;
			title[0] = _T('\0');
			_tcsncat(title, item, title_len);
			page += page_len;
			*rel_page = _tcstoul(page, &end, 10);
			break;
		}
	}
}

/*
 * This procedure writes the start of the table of contents to the given
 * file. The value of fd must not be NULL.
 */
void write_toc_start(FILE* fd, LPCTSTR font, LPCTSTR size)
{
	RT_NOT_NULL(fd);
	RT_NOT_NULL(font);
	RT_NOT_NULL(size);

	if(_ftprintf(fd, _T("<!DOCTYPE html><html><head>")
			_T("<meta charset=\"windows-1252\"/>")
			_T("<title>Table of Contents</title><style>")
			_T(".title{padding:0 4px 1px 0;float:left;}")
			_T(".page{padding:0 0 1px 4px;float:right;}")
			_T(".dots{border-bottom:2px dotted #000;overflow:hidden;}")
			_T("body{font-size:%s;font-family:%s;")
			_T("</style></head><body>")
			_T("<p style=\"text-align:center;\">Table of Contents</p>"),
			size, font) < 0)
		errorout(E_BADF, _T("Failed to write TOC"));
}

/*
 * This procedure writes the given element to the table of contents in
 * the given file. The page number is specified by page and the title is
 * specified by name. The values of fd and name must not be NULL.
 */
void write_toc_item(FILE* fd, LPCTSTR name, unsigned long int page)
{
	LPTSTR name_dup = NULL;
	LPTSTR section_number = NULL;
	unsigned long indentation = 0;

	RT_NOT_NULL(fd);
	RT_NOT_NULL(name);

	name_dup = require_dup_str(name);
	section_number = _tcstok(name_dup, _T("\xa0\x00"));

	if(section_number == NULL)
		errorout(E_STR, _T("Failed to identify section number"));

	section_number = _tcstok(section_number, _T("."));

	while((section_number = _tcstok(NULL, _T("."))) != NULL)
		if(_tcscmp(section_number, _T("0")) != 0)
			indentation += 1;

	free(name_dup);

	if(_ftprintf(fd,
			_T("%s<div style=\"line-height:0.5;margin-left:%luem;\">&nbsp;")
			_T("<div style=\"width: 100%%;\">")
			_T("<div class=title>%s</div>")
			_T("<div class=page>%lu</div>")
			_T("<div class=dots>&nbsp;</div>")
			_T("</div></div>"),
			page == 1 ? _T("") : _T("<br />"), indentation, name, page) < 0)
		errorout(E_BADF, _T("Failed to write TOC element"));
}

/*
 * This procedure writes the end of the table of contents to the given
 * file. The value of fd must not be NULL.
 */
void write_toc_end(FILE* fd)
{
	RT_NOT_NULL(fd);

	if(_fputts(_T("</body></html>"), fd) < 0)
		errorout(E_BADF, _T("Failed to write TOC"));
}

/*
 * This procedure reads the given PDF until the current stream section
 * is finished. The value of file must not be NULL.
 */
static void skip_bin_data(FILE* file)
{
	FILE* file_b = NULL;
	int c = EOF;
	TCHAR name[MAX_PATH + 1] = _T("");
	static const char endstream_str[] = "endstream\n";

	RT_NOT_NULL(file);

	/* Reopen file in binary mode */
	GetFinalPathNameByHandle((HANDLE) _get_osfhandle(fileno(file)), name,
			LENGTHOF(name) - 1, FILE_NAME_NORMALIZED);
	file_b = require_open_file(name, _T("rb"));
	fseek(file_b, ftell(file), SEEK_SET);

	do {
		c = getc(file_b);

		if(c == 'e') {
			long int pos = ftell(file_b);
			char tag[LENGTHOF(endstream_str)] = "";

			ungetc(c, file_b);
			fread(tag, sizeof(tag) - 1, sizeof(tag[0]), file_b);

			if(strncmp(tag, endstream_str,
					LENGTHOF(tag) - 1) != 0) {
				fseek(file_b, pos, SEEK_SET);
			} else {
				break;
			}
		}
	} while(c != EOF);
				
	fseek(file, ftell(file_b), SEEK_SET);
	release_file(file_b);
}

/*
 * Opens a pipe to the PDF getter command for writing the TOC HTML. The
 * structure pointed to by info contains the necessary information about
 * the table of contents. The value pointed to by outline_pdf_file is
 * the ID to use to generate a temporary file name for the PDF output of
 * the command. The values of outline_pdf_id and info must not be NULL.
 * The value returned by this procedure must be passed to _pclose().
 */
FILE* open_toc_stream(UINT* outline_pdf_id, const struct pdf_info* info)
{
	struct wkhtmltopdf_cmd_info toc_cmd_info; /* info for TOC generation */
	FILE* outline_html_file = NULL;
	LPTSTR session_str = NULL;
	LPTSTR footer_url = NULL;
	LPTSTR header_url = NULL;
	TCHAR outline_pdf[MAX_PATH + 1] = _T("");

	RT_NOT_NULL(info);
	RT_NOT_NULL(outline_pdf_id);

	require_tmp_file(outline_pdf, outline_pdf_id);

	/* Open a pipe to a parallel conversion to write the TOC HTML to */
	toc_cmd_info.exe = pdf_getter_exe;
	toc_cmd_info.source = _T("-"); /* source is  stdin */
	toc_cmd_info.target = outline_pdf;
	toc_cmd_info.size = info->cover_page.size;
	toc_cmd_info.orientation = info->cover_page.orientation;
	toc_cmd_info.margins = info->margins;
	toc_cmd_info.options = kPDF_TOC;

	if(info->hf_opts == kPDF_HF_SHOW || info->hf_opts == kPDF_HF_SPECIAL) {
		if(info->session != NULL)
			session_str = require_strf(_T("&SESSION_OVERRIDE=%s"),
				info->session);
		else
			session_str = require_strf(_T(""));

		if(info->footer_url != NULL) {
			footer_url = require_dup_str(info->footer_url);

			if(_tcslen(footer_url) >= INTERNET_MAX_URL_LENGTH)
				errorout(E_STR, _T("Failed to combine base and footer URLs"));

			toc_cmd_info.options |= kPDF_FOOTER;
		}

		if(info->header_url != NULL) {
			header_url = require_dup_str(info->header_url);

			if(_tcslen(header_url) >= INTERNET_MAX_URL_LENGTH)
				errorout(E_STR, _T("Failed to combine base and header URLs"));

			toc_cmd_info.options |= kPDF_HEADER;
		}
	}

	toc_cmd_info.footer_url = footer_url;
	toc_cmd_info.header_url = header_url;
	do_wkhtmltopdf_execute(&outline_html_file, &toc_cmd_info);
	free(session_str);
	free(footer_url);
	free(header_url);

	return outline_html_file;
}
